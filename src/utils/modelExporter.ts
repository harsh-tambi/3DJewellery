// Utility functions to export 3D jewelry models to downloadable formats

export interface ExportableModel {
  vertices: number[]
  indices: number[]
  name?: string
}

// Convert jewelry model to OBJ format
export const exportToOBJ = (models: ExportableModel[]): string => {
  let objContent = '# 3D Jewelry Model\n'
  objContent += '# Generated by Jewelry 3D Platform\n\n'
  
  let vertexOffset = 0
  
  models.forEach((model, modelIndex) => {
    const modelName = model.name || `model_${modelIndex}`
    objContent += `o ${modelName}\n`
    
    // Add vertices (divide by 3 because vertices array is flat [x,y,z,x,y,z,...])
    for (let i = 0; i < model.vertices.length; i += 3) {
      const x = model.vertices[i] || 0
      const y = model.vertices[i + 1] || 0
      const z = model.vertices[i + 2] || 0
      objContent += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`
    }
    
    // Add faces (OBJ uses 1-based indexing)
    if (model.indices && model.indices.length > 0) {
      for (let i = 0; i < model.indices.length; i += 3) {
        const a = model.indices[i] + vertexOffset + 1
        const b = model.indices[i + 1] + vertexOffset + 1
        const c = model.indices[i + 2] + vertexOffset + 1
        objContent += `f ${a} ${b} ${c}\n`
      }
    }
    
    vertexOffset += model.vertices.length / 3
    objContent += '\n'
  })
  
  return objContent
}

// Convert jewelry model to STL format (ASCII)
export const exportToSTL = (models: ExportableModel[]): string => {
  let stlContent = 'solid jewelry_model\n'
  
  models.forEach((model) => {
    if (!model.indices || model.indices.length === 0) return
    
    // Process triangular faces
    for (let i = 0; i < model.indices.length; i += 3) {
      const i1 = model.indices[i] * 3
      const i2 = model.indices[i + 1] * 3
      const i3 = model.indices[i + 2] * 3
      
      // Get vertices
      const v1 = [model.vertices[i1], model.vertices[i1 + 1], model.vertices[i1 + 2]]
      const v2 = [model.vertices[i2], model.vertices[i2 + 1], model.vertices[i2 + 2]]
      const v3 = [model.vertices[i3], model.vertices[i3 + 1], model.vertices[i3 + 2]]
      
      // Calculate normal (simplified - not normalized)
      const normal = [0, 0, 1] // Placeholder normal
      
      stlContent += `facet normal ${normal[0]} ${normal[1]} ${normal[2]}\n`
      stlContent += '  outer loop\n'
      stlContent += `    vertex ${v1[0]} ${v1[1]} ${v1[2]}\n`
      stlContent += `    vertex ${v2[0]} ${v2[1]} ${v2[2]}\n`
      stlContent += `    vertex ${v3[0]} ${v3[1]} ${v3[2]}\n`
      stlContent += '  endloop\n'
      stlContent += 'endfacet\n'
    }
  })
  
  stlContent += 'endsolid jewelry_model\n'
  return stlContent
}

// Download file function
export const downloadFile = (content: string, filename: string, mimeType: string) => {
  const blob = new Blob([content], { type: mimeType })
  const url = URL.createObjectURL(blob)
  
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  
  // Clean up
  URL.revokeObjectURL(url)
}

// Extract exportable models from jewelry data
export const extractModelsFromJewelry = (jewelryData: any): ExportableModel[] => {
  const models: ExportableModel[] = []
  
  // Extract band/main structure
  if (jewelryData.band && jewelryData.band.vertices) {
    models.push({
      vertices: jewelryData.band.vertices,
      indices: jewelryData.band.indices || [],
      name: 'band'
    })
  }
  
  // Extract chain
  if (jewelryData.chain && jewelryData.chain.vertices) {
    models.push({
      vertices: jewelryData.chain.vertices,
      indices: jewelryData.chain.indices || [],
      name: 'chain'
    })
  }
  
  // Extract pendant
  if (jewelryData.pendant && jewelryData.pendant.vertices) {
    models.push({
      vertices: jewelryData.pendant.vertices,
      indices: jewelryData.pendant.indices || [],
      name: 'pendant'
    })
  }
  
  // Extract stones
  if (jewelryData.stones && Array.isArray(jewelryData.stones)) {
    jewelryData.stones.forEach((stone: any, index: number) => {
      if (stone.vertices) {
        models.push({
          vertices: stone.vertices,
          indices: stone.indices || [],
          name: `stone_${index}`
        })
      }
    })
  }
  
  // If no specific parts found, try to export the whole geometry
  if (models.length === 0 && jewelryData.vertices) {
    models.push({
      vertices: jewelryData.vertices,
      indices: jewelryData.indices || [],
      name: 'jewelry'
    })
  }
  
  return models
}
